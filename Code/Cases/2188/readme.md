### 题目描述

小C对字符串颇有研究,他觉得传统的字符串匹配太无聊了，是他想到了这样一个问题。

对于两个长度为n的串A, B ,小C每次会给出给出4个参数s,t,l,r.令A从s到t的子串(从1开始标号）为T,令B从l到r的子串为P。然后他会进行下面的操作:

如果T的某个子串与P相同,我们就可以覆盖T的这个子串，并获得K - i 的收益,中i是初始时A中(注意不是T中）这个子串的起始位置，K 是给定的参数.一个位置不能被覆盖多次.覆盖操作可以进行任意多次,你需要输出获得收益的最大值.

注意每次询问都是独立的,即进行一次询问后, 覆盖的位置会复原.

### 输入描述

```
第一行两个整数n, K，表示字符串长度和参数.
接下来一行一个字符串A.
接下来一行一个字符串B.
接下来一行一个整数q，示询问个数.
接下来q行，每行四个整数s,t,l,r,表示一次询问. 

数据范围：
对于所有数据，有1≤n,q≤10^5, A, B仅由小写英文字母组成，1≤s≤t≤n, 1≤l≤r≤n, n<K≤10^9
对于n= 10^5的测试点，满足51≤r-l≤2000的询问不超过11000个,且r- l在该区间内均匀随机.
```
### 输出描述

```
输出q行，每行一个整数，表示一个询问的答案．
```

### 测试样例
#### 样例1:输入-输出-解释

```
10 11
abcbababab
ababcbabab
5
1 9 7 9
3 10 8 10
1 10 1 2
5 7 2 3
1 5 3 6
```
```
6
10
22
5
10
```
```
对于第一组询问T = abcbababa, P = aba,收益为K - 5= 6.
对于第二组询问T = cbababab, P= bab,收益为(K - 4)+(K- 8)= 10.
```