### 题目描述

九条可怜是一个热爱思考的女孩子。

九条可怜最近正在研究各种排序的性质，她发现了一种很有趣的排序方法： Gobo sort ！

Gobo sort 的算法描述大致如下：

1.假设我们要对一个大小为n的数列a排序。

2.等概率随机生成一个大小为n的排列p。

3.构造一个大小为n的数列b满足b<sub>i</sub>=a<sub>pi</sub>，检查b是否有序，如果b已经有序了就结束算法，并返回b，不然返回步骤2。

显然这个算法的期望时间复杂度是O(n*n!)的，但是九条可怜惊奇的发现，利用量子的神奇性质，在量子系统中，可以把这个算法的时间复杂度优化到线性。

九条可怜对这个排序算法进行了进一步研究，她发现如果一个序列满足一些性质，那么 Gobo sort 会很快计算出正确的结果。为了量化这个速度，她定义 Gobo sort 的执行轮数是步骤2的执行次数。

于是她就想到了这么一个问题：

现在有一个长度为n的序列x，九条可怜会在这个序列后面加入m个元素，每个元素是[l,r]内的正整数。 她希望新的长度为n+m的序列执行 Gobo sort 的期望执行轮数尽量的多。她希望得到这个最多的期望轮数。

九条可怜很聪明，她很快就算出了答案，她希望和你核对一下，由于这个期望轮数实在是太大了，于是她只要求你输出对998244353取模的结果。

### 输入描述

第一行输入一个整数T，表示数据组数。

接下来2*T行描述了T组数据。

每组数据分成两行，第1行有四个正整数n,m,l,r，表示数列的长度和加入数字的个数和加入数字的范围。

第2行有n个正整数，第i个表示x<sub>i</sub>。
### 输出描述

```
输出T个整数，表示答案。
```

### 测试样例
#### 样例1: 输入-输出-解释
```
2
3 3 1 2
1 3 4
3 3 5 7
1 3 4
```
```
180
720
```
```
对于第一组数据，我们可以添加{1,2,2}到序列的最末尾，使得这个序列变成 1 3 4 1 2 2 ，那么进行一轮的成功概率是1/180，因此期望需要 180 轮。
对于第二组数据，我们可以添加{5,6,7}到序列的最末尾，使得这个序列变成 1 3 4 5 6 7 ，那么进行一轮的成功概率是1/720，因此期望需要 720 轮。
```
### 题目来源  
`JXOI`